# Represents a Context-free Grammar, supporting the following operations:
# adding variables
# adding terminals
# adding rules
# setting the start variable
# generating strings accepted by the CFG up to a specified length
# checking if a given string is able to be generated by the CFG
class CFG:
    # initializes the CFG, with optional parameters
    def __init__(self, v=[], t=[], r={}, s="None"):
        self.variables = v
        self.terminals = t
        self.rules = r
        self.start_variable = s

    # adds a new variable to the CFG
    def add_variable(self, v):
        if isinstance(v, str) and len(v) == 1:
            if (v not in self.terminals) and (v not in self.variables):
                self.variables.append(v)
                self.rules[v] = []
                print(v, "added to Variables.")
            else:
                print(v, "is already used.")
        else:
            print("Please enter a valid string.")

    # adds a new character to Terminals
    def add_terminal(self, t):
        if isinstance(t, str) and len(t) == 1:
            if (t not in self.terminals) and (t not in self.variables):
                self.terminals.append(t)
                print(t, "added to Terminals.")
            else:
                print(t, "is already used.")
        else:
            print("Please enter a valid string.")

    # adds a new substitution rule for the given variable in the CFG
    def add_rule(self, v, sub):
        if isinstance(v, str) and isinstance(sub, str):
            if v in self.variables:
                if self.__valid_sub(sub):
                    if sub not in self.rules[v]:
                        subs = self.rules[v]
                        subs.append(sub)
                        self.rules[v] = subs
                    else:
                        print(v, "->", sub, "is already a rule.")
                else:
                    print(sub, "contains characters not in Variables or Terminals.")
            else:
                print(v, "is not a valid variable.")
        else:
            print("Please enter valid string inputs.")

    # checks if every character in the substitution is a terminal or variable
    def __valid_sub(self, sub):
        for c in sub:
            if (c not in self.terminals) and (c not in self.variables):
                return False
        return True

    # add an epsilon substitution to the given variable
    def add_epsilon_sub(self, v):
        if isinstance(v, str):
            if v in self.variables:
                if "Є" not in self.terminals:
                    self.add_terminal("Є")
                if "Є" not in self.rules[v]:
                    subs = self.rules[v]
                    subs.append("Є")
                    self.rules[v] = subs
                else:
                    print(v, "-> Є is already a rule.")
            else:
                print(v, "is not a valid variable.")
        else:
            print("Please enter a valid string input.")

    # sets the start variable to s, if it is valid
    def set_start_variable(self, s):
        if isinstance(s, str):
            if s in self.variables:
                self.start_variable = s
                print(s, "set as start variable.")
            else:
                print(s, "is not a valid variable.")
        else:
            print("Please enter a valid string.")

    # checks if a string is accepted by the CFG
    def isaccepted(self, w):
        if isinstance(w, str):
            strings = self.generate_strings(len(w))
            if w in strings:
                return True
            else:
                return False
            return True
        else:
            print("Please enter a string.")
            return False

    # generates all possible strings to a certain length in the CFG
    def generate_strings(self, length):
        if isinstance(length, int) and length >= 0:
            all_strings = []
            current_strings = [self.start_variable]
            while len(current_strings) > 0:
                temp_strings = []
                copy = current_strings[:]
                for w in copy:
                    temp_strings += self.__substitute(w)
                    current_strings.remove(w)
                current_strings += temp_strings
                copy = current_strings[:]
                for w in current_strings:
                    nw = w.replace("Є", "")
                    if len(nw) <= length and self.__valid_string(nw) and nw not in all_strings:
                        all_strings.append(nw)
                        copy.remove(w)
                    elif self.__count_terminals(nw) > length:
                        copy.remove(w)
                current_strings = copy[:]
            return all_strings
        else:
            print("Please enter a valid length.")
            return []

    # return all possible substitutions of the leftmost variable in a provided string
    def __substitute(self, w):
        v = ""
        for c in w:
            if c in self.variables:
                v = c
                break
        substitutions = []
        if v == "":
            return []
        else:
            for sub in self.rules[v]:
                substitutions.append(w.replace(v, sub, 1))
            return substitutions

    # checks if the string is only made up of terminals
    def __valid_string(self, w):
        for v in self.variables:
            if v in w:
                return False
        return True

    # returns how many terminals are in the string
    def __count_terminals(self, w):
        count = 0
        for c in w:
            if c in self.terminals:
                count += 1
        return count

    # representation of a CFG as a string
    def __repr__(self):
        string = "Variables: " + str(self.variables) + "\nTerminals: " + str(self.terminals) + "\nRules: " + \
                 str(self.rules) + "\nStart Variable: " + str(self.start_variable)
        return string

# allows you to build your own CFG, step by step
# WIP, not complete
if __name__ == '__main__':
    help = "gen i -> generate all strings up to length i\nval s -> check if s can be generated by the CFG\n" \
           "addv v -> add variable v to the CFG\naddt t -> add terminal t to the CFG\n" \
           "addr r -> add rule r (format: v->sub1|sub2) to the CFG\nsetv v -> set variable v as the start variable\nq - exit\n"
    g = CFG()
    print("Let's build a CFG!")
    variables = input("What variables do you want to use? (format: v1, v2, ...)\n")
    terminals = input("What terminals do you want to use? (format: t1, t2, ...) (use Є for empty)\n")
    rules = input("What rules do you want to have? (format: v1->sub1|sub2, v2->sub3|sub4, ...)\n")
    start_variable = input("What do you want to have as your start variable? Options:" + str(variables) + "\n")
    instruction = input("Now, select what you want to do:\n" + help)


